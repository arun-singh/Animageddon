package shared.entities;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;

import org.lwjgl.util.vector.Vector2f;

import shared.World;
import shared.net.NetworkedEntity;
import client.WorldView;

import java.util.ArrayList;
import shared.Polygon;
import shared.MapFile;
import shared.NavMesh;

/**
 * A player controlled by AI logic.
 * @author Chris, Barney
 *
 */
public class AIPlayer extends Player {	
	private NetworkedEntity goalFlag;
	
	private long lastUpdateTime = 0;
	private final long UPDATE_INTERVAL = 300;

	// The last path generated by the AI's pathfinding algorithm
	private ArrayList<Vector2f> path;

	// The navmesh for the map file
	private MapFile mapFile;

	// Stores the previous goal, to avoid having to calculate a new path every time the goal moves
	private Polygon oldGoalPolygon;

	// Stores the last known polygon that the ai character was in
	private Polygon oldPolygon;

	// Stores the next polygon that we expect the character to be in
	private Polygon expectedNextPolygon;

	private ArrayList<Polygon> expectedPolygonPath;
	
	public AIPlayer(World world, int x, int y, Flag goalFlag, MapFile mapFile) {
		super(world, x, y);

		createNetworkFields();
		
		this.goalFlag.set(goalFlag);

		this.mapFile = mapFile;
	}
	
	public AIPlayer(World world, DataInputStream in) throws IOException {
		super(world, in);
				
		createNetworkFields();
		readNetworkFields(in);
	}
	
	private void createNetworkFields() {
		this.goalFlag = new NetworkedEntity(this);
	}
	
	private void readNetworkFields(DataInputStream in) throws IOException {
		this.goalFlag.readFromNetStream(in);
	}

	@Override
	public void writeToNetStream(DataOutputStream out) throws IOException {
		super.writeToNetStream(out);
		
		this.goalFlag.writeToNetStream(out);
	}

	@Override
	public void update(int delta) {		
		
		super.update(delta);
		
		World thisWorld = this.getWorld();
		
		if (this.getIsDead())
			return;
		
		if (thisWorld.isClient())
			return;

		if (thisWorld.getTime() - this.lastUpdateTime < UPDATE_INTERVAL)
			return;
		
		this.lastUpdateTime = thisWorld.getTime();

		// final because they are used with threads below
		final Vector2f aiPosition = this.getPosition();
		final Vector2f goalPosition;

		Flag goalFlag = (Flag)this.goalFlag.get();
		Player flagHolder = goalFlag.getFlagHolder();

		if (flagHolder != null) {
			if (flagHolder.getTeam().getID() != this.getTeam().getID()) {
				// Shoot
				calculateAimVec(flagHolder.getPosition(), thisWorld);
				shoot();
			}
		}

		if (heldFlag.get() == null) {
			goalPosition = this.goalFlag.get().getPosition();
		} else {
			goalPosition = this.getTeam().getFlagCaptureRegion().getPosition();
		}

		// First we check whether we are in the same navmesh polygon as the goal, if so then we don't need to do any complex pathfinding
		NavMesh navMesh = this.getMapFile().getNavMesh();
		Polygon aiPolygon = navMesh.getPolygonContaining(aiPosition);
		Polygon goalPolygon = navMesh.getPolygonContaining(goalPosition);
		if (aiPolygon.equals(goalPolygon)) {
			// Simply work out the shortest path, because we are in the same convex polygon as the goal we can get to it using a straight line
			Vector2f movementVector = new Vector2f(goalPosition.getX()-aiPosition.getX(), goalPosition.getY()-aiPosition.getY());
			if (movementVector.length() != 0) {
				movementVector.normalise();
				movementVector.scale(this.getSpeed());
			}
			this.setVelocity(movementVector);
			
			// Set the path to null to clear any old paths
			if (this.getPath() != null) {
				this.setPath(null);
			}
		}
		// If there is no path to follow, or the path has become invalid, we need to calculate a new path
		else if (this.getPath() == null || !this.oldGoalPolygon.equals(goalPolygon)) {
			// Store the old polygon so that we know when we need to update the path
			// Also stop the player from moving so that we don't change the start position
			this.oldGoalPolygon = goalPolygon;
			this.setVelocity(new Vector2f(0.0f, 0.0f));

			// Start a new thread to calculate the new path
			(new Thread(new Runnable() {
				public void run() {
					ArrayList<Vector2f> newPath = calculateNewPath(aiPosition, goalPosition);
					setPath(newPath);
				}
			})).start();
		}
		// Follow the current path
		else {
			this.calculateAndSetMovementVector(aiPolygon);
		}
		
		if (flagHolder != null) {
			if (flagHolder.getTeam().getID() != this.getTeam().getID()) {
				// Shoot
				calculateAimVec(flagHolder.getPosition(), thisWorld);
				shoot();
			}
		}
	}

	/**
	 * Calculates the path that gets the character to the goal, whilst avoiding static obstacles, via the shortest path. (thread-safe)
	 * @param start The start position of the path
	 * @param goal The goal position of the path
	 * @return The list of vertices to follow
	 */
	private ArrayList<Vector2f> calculateNewPath(Vector2f start, Vector2f goal) {
		// Get the navmesh
		NavMesh navMesh = this.getMapFile().getNavMesh();

		// Use a* search to find the shortest polygon path between the navigation mesh
		ArrayList<Polygon> polygonPath = navMesh.aStar(start, goal);

		// Store the polygon path so that we can check the character hasn't strayed from the path
		// Move the first element from the path and into the next expected polygon, because we expect to be in there
		this.setExpectedPolygonPath(new ArrayList<Polygon>(polygonPath));
		this.setExpectedNextPolygon(this.getExpectedPolygonPath().remove(0));
		
		// Convert the polygon path to points on the map that we can use to navigate
		ArrayList<Vector2f> pointPath = navMesh.polygonPathToPointPath(polygonPath);

		// Reset the oldPolygon so that the tests don't get confused
		this.setOldPolygon(null);
		
		return pointPath;
	}

	/**
	 * Works out the movement vector that reflects the stored path
	 * @param currentPolygon The current polygon that the ai character is in
	 */
	private void calculateAndSetMovementVector(Polygon currentPolygon) {
		// If we haven't changed polygons yet then we don't need to calculate a new vector
		if (currentPolygon.equals(this.getOldPolygon())) {
			return;
		}

		// Also check that we are in the expected polygon, if we're not then we need to calculate a new path
		// This may occur when we move through an entire polygon before the next movement vector has been calculated
		// For example, when we move through a very small polygon
		if (!currentPolygon.equals(this.getExpectedNextPolygon())) {
			// Cause a new path to be generated
			this.setPath(null);
			return;
		}

		// Store the current polygon so that we know whether we need to calcluate a new vector or not
		this.setOldPolygon(currentPolygon);

		// Store the next expected polygon so that we can check whether the AI character has strayed from the path
		try {
			this.setExpectedNextPolygon(this.getExpectedPolygonPath().remove(0));
		} catch (IndexOutOfBoundsException ex) {
			// Do nothing, this just means that we are currently in the goal polygon, we should probably never get here
		}

		// Get the from and to points for the AI
		Vector2f aiPosition = this.getPosition();
		Vector2f nextPoint = this.getPath().remove(0);

		// Calculate the movement vector
		Vector2f movementVector = Vector2f.sub(nextPoint, aiPosition, null);

		// Make sure that the velocity is constant, the only thing that changes is the direction
		if (movementVector.length() != 0) {
			movementVector.normalise();
			movementVector.scale(this.getSpeed());
		}
		
		// Set the movement vector
		this.setVelocity(movementVector);
	}
	
	@Override
	public void render(WorldView view) {
		super.render(view);
		
		//Vector2f p = getPosition();	
		//view.drawWorldRectangle(p.getX(), p.getY(), WIDTH, HEIGHT, 1.0f, 0.0f, 1.0f, true);	
	}

	/**
	 * Gets the last known polygon that the character was in (thread-safe)
	 * @return The last known polygon
	 */
	private synchronized Polygon getOldPolygon() {
		return this.oldPolygon;
	}

	/**
	 * Sets the last known polygon that the character was in (thread-safe)
	 * @param polygon The last known polygon
	 */
	private synchronized void setOldPolygon(Polygon polygon) {
		this.oldPolygon = polygon;
	}

	/**
	 * Gets the currently stored path (thread-safe)
	 * @return The path
	 */
	private synchronized ArrayList<Vector2f> getPath() {
		return this.path;
	}

	/**
	 * Sets the path (thread-safe)
	 * @param path The new path
	 */
	private synchronized void setPath(ArrayList<Vector2f> path) {
		this.path = path;
	}

	/**
	 * Gets the next expected polygon in the path (thread-safe)
	 * @return The next expected polygon
	 */
	private synchronized Polygon getExpectedNextPolygon() {
		return this.expectedNextPolygon;
	}

	/**
	 * Sets the next expected polygon in the path (thread-safe)
	 * @param polygon The next expected polygon
	 */
	private synchronized void setExpectedNextPolygon(Polygon polygon) {
		this.expectedNextPolygon = polygon;
	}

	/**
	 * Gets the expected polygon path (thread-safe)
	 * @return The expected polygon path
	 */
	private synchronized ArrayList<Polygon> getExpectedPolygonPath() {
		return this.expectedPolygonPath;
	}

	/**
	 * Sets the expected polygon path (thread-safe)
	 * @param polygonPath The expected polygon path
	 */
	private synchronized void setExpectedPolygonPath(ArrayList<Polygon> polygonPath) {
		this.expectedPolygonPath = polygonPath;
	}

	/**
	 * Gets the map file (thread-safe)
	 * @return The map file
	 */
	private synchronized MapFile getMapFile() {
		return this.mapFile;
	}
}
